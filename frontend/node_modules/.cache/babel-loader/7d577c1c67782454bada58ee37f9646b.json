{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport { IJsonRpcProvider, isJsonRpcResponse, formatJsonRpcRequest, isJsonRpcError } from \"@walletconnect/jsonrpc-utils\";\nexport class JsonRpcProvider extends IJsonRpcProvider {\n  constructor(connection) {\n    super(connection);\n    this.events = new EventEmitter();\n    this.connection = this.setConnection(connection);\n  }\n\n  async connect() {\n    let connection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.connection;\n    await this.open(connection);\n  }\n\n  async disconnect() {\n    await this.close();\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async request(request, context) {\n    return this.requestStrict(formatJsonRpcRequest(request.method, request.params || []), context);\n  }\n\n  async requestStrict(request, context) {\n    return new Promise(async (resolve, reject) => {\n      if (!this.connection.connected) {\n        try {\n          await this.open();\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      this.events.on(`${request.id}`, response => {\n        if (isJsonRpcError(response)) {\n          reject(response.error.message);\n        } else {\n          resolve(response.result);\n        }\n      });\n\n      try {\n        await this.connection.send(request, context);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  setConnection() {\n    let connection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.connection;\n    return connection;\n  }\n\n  onPayload(payload) {\n    this.events.emit(\"payload\", payload);\n\n    if (isJsonRpcResponse(payload)) {\n      this.events.emit(`${payload.id}`, payload);\n    } else {\n      this.events.emit(\"message\", {\n        type: payload.method,\n        data: payload.params\n      });\n    }\n  }\n\n  async open() {\n    let connection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.connection;\n    if (this.connection === connection && this.connection.connected) return;\n    if (this.connection.connected) this.close();\n\n    if (typeof connection === \"string\") {\n      await this.connection.open(connection);\n      connection = this.connection;\n    }\n\n    this.connection = this.setConnection(connection);\n    await this.connection.open();\n    this.connection.on(\"payload\", payload => this.onPayload(payload));\n    this.connection.on(\"close\", () => this.events.emit(\"disconnect\"));\n    this.connection.on(\"error\", error => this.events.emit(\"error\", error));\n    this.events.emit(\"connect\");\n  }\n\n  async close() {\n    await this.connection.close();\n    this.events.emit(\"disconnect\");\n  }\n\n}\nexport default JsonRpcProvider;","map":{"version":3,"sources":["../../src/provider.ts"],"names":[],"mappings":"AAAA,SAAS,YAAT,QAA6B,QAA7B;AACA,SAEE,gBAFF,EAOE,iBAPF,EAQE,oBARF,EASE,cATF,QAUO,8BAVP;AAYA,OAAM,MAAO,eAAP,SAA+B,gBAA/B,CAA+C;AAKnD,EAAA,WAAA,CAAY,UAAZ,EAA0C;AACxC,UAAM,UAAN;AALK,SAAA,MAAA,GAAS,IAAI,YAAJ,EAAT;AAML,SAAK,UAAL,GAAkB,KAAK,aAAL,CAAmB,UAAnB,CAAlB;AACD;;AAEmB,QAAP,OAAO,GAA0D;AAAA,QAAzD,UAAyD,uEAAf,KAAK,UAAU;AAC5E,UAAM,KAAK,IAAL,CAAU,UAAV,CAAN;AACD;;AAEsB,QAAV,UAAU,GAAA;AACrB,UAAM,KAAK,KAAL,EAAN;AACD;;AAEM,EAAA,EAAE,CAAC,KAAD,EAAgB,QAAhB,EAA6B;AACpC,SAAK,MAAL,CAAY,EAAZ,CAAe,KAAf,EAAsB,QAAtB;AACD;;AAEM,EAAA,IAAI,CAAC,KAAD,EAAgB,QAAhB,EAA6B;AACtC,SAAK,MAAL,CAAY,IAAZ,CAAiB,KAAjB,EAAwB,QAAxB;AACD;;AAEM,EAAA,GAAG,CAAC,KAAD,EAAgB,QAAhB,EAA6B;AACrC,SAAK,MAAL,CAAY,GAAZ,CAAgB,KAAhB,EAAuB,QAAvB;AACD;;AAEM,EAAA,cAAc,CAAC,KAAD,EAAgB,QAAhB,EAA6B;AAChD,SAAK,MAAL,CAAY,cAAZ,CAA2B,KAA3B,EAAkC,QAAlC;AACD;;AAEmB,QAAP,OAAO,CAClB,OADkB,EAElB,OAFkB,EAEL;AAEb,WAAO,KAAK,aAAL,CAAmB,oBAAoB,CAAC,OAAO,CAAC,MAAT,EAAiB,OAAO,CAAC,MAAR,IAAkB,EAAnC,CAAvC,EAA+E,OAA/E,CAAP;AACD;;AAI4B,QAAb,aAAa,CAC3B,OAD2B,EAE3B,OAF2B,EAEd;AAEb,WAAO,IAAI,OAAJ,CAAY,OAAO,OAAP,EAAgB,MAAhB,KAA0B;AAC3C,UAAI,CAAC,KAAK,UAAL,CAAgB,SAArB,EAAgC;AAC9B,YAAI;AACF,gBAAM,KAAK,IAAL,EAAN;AACD,SAFD,CAEE,OAAO,CAAP,EAAU;AACV,UAAA,MAAM,CAAC,CAAD,CAAN;AACD;AACF;;AACD,WAAK,MAAL,CAAY,EAAZ,CAAe,GAAG,OAAO,CAAC,EAAE,EAA5B,EAAgC,QAAQ,IAAG;AACzC,YAAI,cAAc,CAAC,QAAD,CAAlB,EAA8B;AAC5B,UAAA,MAAM,CAAC,QAAQ,CAAC,KAAT,CAAe,OAAhB,CAAN;AACD,SAFD,MAEO;AACL,UAAA,OAAO,CAAC,QAAQ,CAAC,MAAV,CAAP;AACD;AACF,OAND;;AAOA,UAAI;AACF,cAAM,KAAK,UAAL,CAAgB,IAAhB,CAAqB,OAArB,EAA8B,OAA9B,CAAN;AACD,OAFD,CAEE,OAAO,CAAP,EAAU;AACV,QAAA,MAAM,CAAC,CAAD,CAAN;AACD;AACF,KApBM,CAAP;AAqBD;;AAES,EAAA,aAAa,GAAiD;AAAA,QAAhD,UAAgD,uEAAf,KAAK,UAAU;AACtE,WAAO,UAAP;AACD;;AAES,EAAA,SAAS,CAAC,OAAD,EAAwB;AACzC,SAAK,MAAL,CAAY,IAAZ,CAAiB,SAAjB,EAA4B,OAA5B;;AACA,QAAI,iBAAiB,CAAC,OAAD,CAArB,EAAgC;AAC9B,WAAK,MAAL,CAAY,IAAZ,CAAiB,GAAG,OAAO,CAAC,EAAE,EAA9B,EAAkC,OAAlC;AACD,KAFD,MAEO;AACL,WAAK,MAAL,CAAY,IAAZ,CAAiB,SAAjB,EAA4B;AAC1B,QAAA,IAAI,EAAE,OAAO,CAAC,MADY;AAE1B,QAAA,IAAI,EAAE,OAAO,CAAC;AAFY,OAA5B;AAID;AACF;;AAEmB,QAAJ,IAAI,GAA0D;AAAA,QAAzD,UAAyD,uEAAf,KAAK,UAAU;AAC5E,QAAI,KAAK,UAAL,KAAoB,UAApB,IAAkC,KAAK,UAAL,CAAgB,SAAtD,EAAiE;AACjE,QAAI,KAAK,UAAL,CAAgB,SAApB,EAA+B,KAAK,KAAL;;AAC/B,QAAI,OAAO,UAAP,KAAsB,QAA1B,EAAoC;AAClC,YAAM,KAAK,UAAL,CAAgB,IAAhB,CAAqB,UAArB,CAAN;AACA,MAAA,UAAU,GAAG,KAAK,UAAlB;AACD;;AACD,SAAK,UAAL,GAAkB,KAAK,aAAL,CAAmB,UAAnB,CAAlB;AACA,UAAM,KAAK,UAAL,CAAgB,IAAhB,EAAN;AACA,SAAK,UAAL,CAAgB,EAAhB,CAAmB,SAAnB,EAA+B,OAAD,IAA6B,KAAK,SAAL,CAAe,OAAf,CAA3D;AACA,SAAK,UAAL,CAAgB,EAAhB,CAAmB,OAAnB,EAA4B,MAAM,KAAK,MAAL,CAAY,IAAZ,CAAiB,YAAjB,CAAlC;AACA,SAAK,UAAL,CAAgB,EAAhB,CAAmB,OAAnB,EAA6B,KAAD,IAAkB,KAAK,MAAL,CAAY,IAAZ,CAAiB,OAAjB,EAA0B,KAA1B,CAA9C;AACA,SAAK,MAAL,CAAY,IAAZ,CAAiB,SAAjB;AACD;;AAEoB,QAAL,KAAK,GAAA;AACnB,UAAM,KAAK,UAAL,CAAgB,KAAhB,EAAN;AACA,SAAK,MAAL,CAAY,IAAZ,CAAiB,YAAjB;AACD;;AAxGkD;AA2GrD,eAAe,eAAf","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport { IJsonRpcProvider, isJsonRpcResponse, formatJsonRpcRequest, isJsonRpcError, } from \"@walletconnect/jsonrpc-utils\";\nexport class JsonRpcProvider extends IJsonRpcProvider {\n    constructor(connection) {\n        super(connection);\n        this.events = new EventEmitter();\n        this.connection = this.setConnection(connection);\n    }\n    async connect(connection = this.connection) {\n        await this.open(connection);\n    }\n    async disconnect() {\n        await this.close();\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async request(request, context) {\n        return this.requestStrict(formatJsonRpcRequest(request.method, request.params || []), context);\n    }\n    async requestStrict(request, context) {\n        return new Promise(async (resolve, reject) => {\n            if (!this.connection.connected) {\n                try {\n                    await this.open();\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }\n            this.events.on(`${request.id}`, response => {\n                if (isJsonRpcError(response)) {\n                    reject(response.error.message);\n                }\n                else {\n                    resolve(response.result);\n                }\n            });\n            try {\n                await this.connection.send(request, context);\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    }\n    setConnection(connection = this.connection) {\n        return connection;\n    }\n    onPayload(payload) {\n        this.events.emit(\"payload\", payload);\n        if (isJsonRpcResponse(payload)) {\n            this.events.emit(`${payload.id}`, payload);\n        }\n        else {\n            this.events.emit(\"message\", {\n                type: payload.method,\n                data: payload.params,\n            });\n        }\n    }\n    async open(connection = this.connection) {\n        if (this.connection === connection && this.connection.connected)\n            return;\n        if (this.connection.connected)\n            this.close();\n        if (typeof connection === \"string\") {\n            await this.connection.open(connection);\n            connection = this.connection;\n        }\n        this.connection = this.setConnection(connection);\n        await this.connection.open();\n        this.connection.on(\"payload\", (payload) => this.onPayload(payload));\n        this.connection.on(\"close\", () => this.events.emit(\"disconnect\"));\n        this.connection.on(\"error\", (error) => this.events.emit(\"error\", error));\n        this.events.emit(\"connect\");\n    }\n    async close() {\n        await this.connection.close();\n        this.events.emit(\"disconnect\");\n    }\n}\nexport default JsonRpcProvider;\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}