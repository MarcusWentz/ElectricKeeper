{"ast":null,"code":"import { parsePersonalSign, parseTransactionData, convertArrayBufferToHex, convertHexToArrayBuffer, getClientMeta, payloadId, uuid, formatRpcError, parseWalletConnectUri, convertNumberToHex, isJsonRpcResponseSuccess, isJsonRpcResponseError, isSilentPayload, getLocal, signingMethods, mobileLinkChoiceKey, isMobile, removeLocal } from \"@walletconnect/utils\";\nimport SocketTransport from \"@walletconnect/socket-transport\";\nimport { ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_MISSING_REQUIRED, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED } from \"./errors\";\nimport EventManager from \"./events\";\nimport SessionStorage from \"./storage\";\nimport { getBridgeUrl } from \"./url\";\n\nclass Connector {\n  constructor(opts) {\n    this.protocol = \"wc\";\n    this.version = 1;\n    this._bridge = \"\";\n    this._key = null;\n    this._clientId = \"\";\n    this._clientMeta = null;\n    this._peerId = \"\";\n    this._peerMeta = null;\n    this._handshakeId = 0;\n    this._handshakeTopic = \"\";\n    this._connected = false;\n    this._accounts = [];\n    this._chainId = 0;\n    this._networkId = 0;\n    this._rpcUrl = \"\";\n    this._eventManager = new EventManager();\n    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;\n    this._cryptoLib = opts.cryptoLib;\n    this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);\n    this._qrcodeModal = opts.connectorOpts.qrcodeModal;\n    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;\n    this._signingMethods = [...signingMethods, ...(opts.connectorOpts.signingMethods || [])];\n\n    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {\n      throw new Error(ERROR_MISSING_REQUIRED);\n    }\n\n    if (opts.connectorOpts.bridge) {\n      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);\n    }\n\n    if (opts.connectorOpts.uri) {\n      this.uri = opts.connectorOpts.uri;\n    }\n\n    const session = opts.connectorOpts.session || this._getStorageSession();\n\n    if (session) {\n      this.session = session;\n    }\n\n    if (this.handshakeId) {\n      this._subscribeToSessionResponse(this.handshakeId, \"Session request rejected\");\n    }\n\n    this._transport = opts.transport || new SocketTransport({\n      protocol: this.protocol,\n      version: this.version,\n      url: this.bridge,\n      subscriptions: [this.clientId]\n    });\n\n    this._subscribeToInternalEvents();\n\n    this._initTransport();\n\n    if (opts.connectorOpts.uri) {\n      this._subscribeToSessionRequest();\n    }\n\n    if (opts.pushServerOpts) {\n      this._registerPushServer(opts.pushServerOpts);\n    }\n  }\n\n  set bridge(value) {\n    if (!value) {\n      return;\n    }\n\n    this._bridge = value;\n  }\n\n  get bridge() {\n    return this._bridge;\n  }\n\n  set key(value) {\n    if (!value) {\n      return;\n    }\n\n    const key = convertHexToArrayBuffer(value);\n    this._key = key;\n  }\n\n  get key() {\n    if (this._key) {\n      const key = convertArrayBufferToHex(this._key, true);\n      return key;\n    }\n\n    return \"\";\n  }\n\n  set clientId(value) {\n    if (!value) {\n      return;\n    }\n\n    this._clientId = value;\n  }\n\n  get clientId() {\n    let clientId = this._clientId;\n\n    if (!clientId) {\n      clientId = this._clientId = uuid();\n    }\n\n    return this._clientId;\n  }\n\n  set peerId(value) {\n    if (!value) {\n      return;\n    }\n\n    this._peerId = value;\n  }\n\n  get peerId() {\n    return this._peerId;\n  }\n\n  set clientMeta(value) {}\n\n  get clientMeta() {\n    let clientMeta = this._clientMeta;\n\n    if (!clientMeta) {\n      clientMeta = this._clientMeta = getClientMeta();\n    }\n\n    return clientMeta;\n  }\n\n  set peerMeta(value) {\n    this._peerMeta = value;\n  }\n\n  get peerMeta() {\n    const peerMeta = this._peerMeta;\n    return peerMeta;\n  }\n\n  set handshakeTopic(value) {\n    if (!value) {\n      return;\n    }\n\n    this._handshakeTopic = value;\n  }\n\n  get handshakeTopic() {\n    return this._handshakeTopic;\n  }\n\n  set handshakeId(value) {\n    if (!value) {\n      return;\n    }\n\n    this._handshakeId = value;\n  }\n\n  get handshakeId() {\n    return this._handshakeId;\n  }\n\n  get uri() {\n    const _uri = this._formatUri();\n\n    return _uri;\n  }\n\n  set uri(value) {\n    if (!value) {\n      return;\n    }\n\n    const {\n      handshakeTopic,\n      bridge,\n      key\n    } = this._parseUri(value);\n\n    this.handshakeTopic = handshakeTopic;\n    this.bridge = bridge;\n    this.key = key;\n  }\n\n  set chainId(value) {\n    this._chainId = value;\n  }\n\n  get chainId() {\n    const chainId = this._chainId;\n    return chainId;\n  }\n\n  set networkId(value) {\n    this._networkId = value;\n  }\n\n  get networkId() {\n    const networkId = this._networkId;\n    return networkId;\n  }\n\n  set accounts(value) {\n    this._accounts = value;\n  }\n\n  get accounts() {\n    const accounts = this._accounts;\n    return accounts;\n  }\n\n  set rpcUrl(value) {\n    this._rpcUrl = value;\n  }\n\n  get rpcUrl() {\n    const rpcUrl = this._rpcUrl;\n    return rpcUrl;\n  }\n\n  set connected(value) {}\n\n  get connected() {\n    return this._connected;\n  }\n\n  set pending(value) {}\n\n  get pending() {\n    return !!this._handshakeTopic;\n  }\n\n  get session() {\n    return {\n      connected: this.connected,\n      accounts: this.accounts,\n      chainId: this.chainId,\n      bridge: this.bridge,\n      key: this.key,\n      clientId: this.clientId,\n      clientMeta: this.clientMeta,\n      peerId: this.peerId,\n      peerMeta: this.peerMeta,\n      handshakeId: this.handshakeId,\n      handshakeTopic: this.handshakeTopic\n    };\n  }\n\n  set session(value) {\n    if (!value) {\n      return;\n    }\n\n    this._connected = value.connected;\n    this.accounts = value.accounts;\n    this.chainId = value.chainId;\n    this.bridge = value.bridge;\n    this.key = value.key;\n    this.clientId = value.clientId;\n    this.clientMeta = value.clientMeta;\n    this.peerId = value.peerId;\n    this.peerMeta = value.peerMeta;\n    this.handshakeId = value.handshakeId;\n    this.handshakeTopic = value.handshakeTopic;\n  }\n\n  on(event, callback) {\n    const eventEmitter = {\n      event,\n      callback\n    };\n\n    this._eventManager.subscribe(eventEmitter);\n  }\n\n  off(event) {\n    this._eventManager.unsubscribe(event);\n  }\n\n  async createInstantRequest(instantRequest) {\n    this._key = await this._generateKey();\n\n    const request = this._formatRequest({\n      method: \"wc_instantRequest\",\n      params: [{\n        peerId: this.clientId,\n        peerMeta: this.clientMeta,\n        request: this._formatRequest(instantRequest)\n      }]\n    });\n\n    this.handshakeId = request.id;\n    this.handshakeTopic = uuid();\n\n    this._eventManager.trigger({\n      event: \"display_uri\",\n      params: [this.uri]\n    });\n\n    this.on(\"modal_closed\", () => {\n      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);\n    });\n\n    const endInstantRequest = () => {\n      this.killSession();\n    };\n\n    try {\n      const result = await this._sendCallRequest(request);\n\n      if (result) {\n        endInstantRequest();\n      }\n\n      return result;\n    } catch (error) {\n      endInstantRequest();\n      throw error;\n    }\n  }\n\n  async connect(opts) {\n    if (!this._qrcodeModal) {\n      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);\n    }\n\n    if (this.connected) {\n      return {\n        chainId: this.chainId,\n        accounts: this.accounts\n      };\n    }\n\n    await this.createSession(opts);\n    return new Promise(async (resolve, reject) => {\n      this.on(\"modal_closed\", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));\n      this.on(\"connect\", (error, payload) => {\n        if (error) {\n          return reject(error);\n        }\n\n        resolve(payload.params[0]);\n      });\n    });\n  }\n\n  async createSession(opts) {\n    if (this._connected) {\n      throw new Error(ERROR_SESSION_CONNECTED);\n    }\n\n    if (this.pending) {\n      return;\n    }\n\n    this._key = await this._generateKey();\n\n    const request = this._formatRequest({\n      method: \"wc_sessionRequest\",\n      params: [{\n        peerId: this.clientId,\n        peerMeta: this.clientMeta,\n        chainId: opts && opts.chainId ? opts.chainId : null\n      }]\n    });\n\n    this.handshakeId = request.id;\n    this.handshakeTopic = uuid();\n\n    this._sendSessionRequest(request, \"Session update rejected\", {\n      topic: this.handshakeTopic\n    });\n\n    this._eventManager.trigger({\n      event: \"display_uri\",\n      params: [this.uri]\n    });\n  }\n\n  approveSession(sessionStatus) {\n    if (this._connected) {\n      throw new Error(ERROR_SESSION_CONNECTED);\n    }\n\n    this.chainId = sessionStatus.chainId;\n    this.accounts = sessionStatus.accounts;\n    this.networkId = sessionStatus.networkId || 0;\n    this.rpcUrl = sessionStatus.rpcUrl || \"\";\n    const sessionParams = {\n      approved: true,\n      chainId: this.chainId,\n      networkId: this.networkId,\n      accounts: this.accounts,\n      rpcUrl: this.rpcUrl,\n      peerId: this.clientId,\n      peerMeta: this.clientMeta\n    };\n    const response = {\n      id: this.handshakeId,\n      jsonrpc: \"2.0\",\n      result: sessionParams\n    };\n\n    this._sendResponse(response);\n\n    this._connected = true;\n\n    this._setStorageSession();\n\n    this._eventManager.trigger({\n      event: \"connect\",\n      params: [{\n        peerId: this.peerId,\n        peerMeta: this.peerMeta,\n        chainId: this.chainId,\n        accounts: this.accounts\n      }]\n    });\n  }\n\n  rejectSession(sessionError) {\n    if (this._connected) {\n      throw new Error(ERROR_SESSION_CONNECTED);\n    }\n\n    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;\n\n    const response = this._formatResponse({\n      id: this.handshakeId,\n      error: {\n        message\n      }\n    });\n\n    this._sendResponse(response);\n\n    this._connected = false;\n\n    this._eventManager.trigger({\n      event: \"disconnect\",\n      params: [{\n        message\n      }]\n    });\n\n    this._removeStorageSession();\n  }\n\n  updateSession(sessionStatus) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n\n    this.chainId = sessionStatus.chainId;\n    this.accounts = sessionStatus.accounts;\n    this.networkId = sessionStatus.networkId || 0;\n    this.rpcUrl = sessionStatus.rpcUrl || \"\";\n    const sessionParams = {\n      approved: true,\n      chainId: this.chainId,\n      networkId: this.networkId,\n      accounts: this.accounts,\n      rpcUrl: this.rpcUrl\n    };\n\n    const request = this._formatRequest({\n      method: \"wc_sessionUpdate\",\n      params: [sessionParams]\n    });\n\n    this._sendSessionRequest(request, \"Session update rejected\");\n\n    this._eventManager.trigger({\n      event: \"session_update\",\n      params: [{\n        chainId: this.chainId,\n        accounts: this.accounts\n      }]\n    });\n\n    this._manageStorageSession();\n  }\n\n  async killSession(sessionError) {\n    const message = sessionError ? sessionError.message : \"Session Disconnected\";\n    const sessionParams = {\n      approved: false,\n      chainId: null,\n      networkId: null,\n      accounts: null\n    };\n\n    const request = this._formatRequest({\n      method: \"wc_sessionUpdate\",\n      params: [sessionParams]\n    });\n\n    await this._sendRequest(request);\n\n    this._handleSessionDisconnect(message);\n  }\n\n  async sendTransaction(tx) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n\n    const parsedTx = parseTransactionData(tx);\n\n    const request = this._formatRequest({\n      method: \"eth_sendTransaction\",\n      params: [parsedTx]\n    });\n\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n\n  async signTransaction(tx) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n\n    const parsedTx = parseTransactionData(tx);\n\n    const request = this._formatRequest({\n      method: \"eth_signTransaction\",\n      params: [parsedTx]\n    });\n\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n\n  async signMessage(params) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n\n    const request = this._formatRequest({\n      method: \"eth_sign\",\n      params\n    });\n\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n\n  async signPersonalMessage(params) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n\n    params = parsePersonalSign(params);\n\n    const request = this._formatRequest({\n      method: \"personal_sign\",\n      params\n    });\n\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n\n  async signTypedData(params) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n\n    const request = this._formatRequest({\n      method: \"eth_signTypedData\",\n      params\n    });\n\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n\n  async updateChain(chainParams) {\n    if (!this._connected) {\n      throw new Error(\"Session currently disconnected\");\n    }\n\n    const request = this._formatRequest({\n      method: \"wallet_updateChain\",\n      params: [chainParams]\n    });\n\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n\n  unsafeSend(request, options) {\n    this._sendRequest(request, options);\n\n    this._eventManager.trigger({\n      event: \"call_request_sent\",\n      params: [{\n        request,\n        options\n      }]\n    });\n\n    return new Promise((resolve, reject) => {\n      this._subscribeToResponse(request.id, (error, payload) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        if (!payload) {\n          throw new Error(ERROR_MISSING_JSON_RPC);\n        }\n\n        resolve(payload);\n      });\n    });\n  }\n\n  async sendCustomRequest(request, options) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n\n    switch (request.method) {\n      case \"eth_accounts\":\n        return this.accounts;\n\n      case \"eth_chainId\":\n        return convertNumberToHex(this.chainId);\n\n      case \"eth_sendTransaction\":\n      case \"eth_signTransaction\":\n        if (request.params) {\n          request.params[0] = parseTransactionData(request.params[0]);\n        }\n\n        break;\n\n      case \"personal_sign\":\n        if (request.params) {\n          request.params = parsePersonalSign(request.params);\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    const formattedRequest = this._formatRequest(request);\n\n    const result = await this._sendCallRequest(formattedRequest, options);\n    return result;\n  }\n\n  approveRequest(response) {\n    if (isJsonRpcResponseSuccess(response)) {\n      const formattedResponse = this._formatResponse(response);\n\n      this._sendResponse(formattedResponse);\n    } else {\n      throw new Error(ERROR_MISSING_RESULT);\n    }\n  }\n\n  rejectRequest(response) {\n    if (isJsonRpcResponseError(response)) {\n      const formattedResponse = this._formatResponse(response);\n\n      this._sendResponse(formattedResponse);\n    } else {\n      throw new Error(ERROR_MISSING_ERROR);\n    }\n  }\n\n  transportClose() {\n    this._transport.close();\n  }\n\n  async _sendRequest(request, options) {\n    const callRequest = this._formatRequest(request);\n\n    const encryptionPayload = await this._encrypt(callRequest);\n    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== \"undefined\" ? options.topic : this.peerId;\n    const payload = JSON.stringify(encryptionPayload);\n    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== \"undefined\" ? !options.forcePushNotification : isSilentPayload(callRequest);\n\n    this._transport.send(payload, topic, silent);\n  }\n\n  async _sendResponse(response) {\n    const encryptionPayload = await this._encrypt(response);\n    const topic = this.peerId;\n    const payload = JSON.stringify(encryptionPayload);\n    const silent = true;\n\n    this._transport.send(payload, topic, silent);\n  }\n\n  async _sendSessionRequest(request, errorMsg, options) {\n    this._sendRequest(request, options);\n\n    this._subscribeToSessionResponse(request.id, errorMsg);\n  }\n\n  _sendCallRequest(request, options) {\n    this._sendRequest(request, options);\n\n    this._eventManager.trigger({\n      event: \"call_request_sent\",\n      params: [{\n        request,\n        options\n      }]\n    });\n\n    return this._subscribeToCallResponse(request.id);\n  }\n\n  _formatRequest(request) {\n    if (typeof request.method === \"undefined\") {\n      throw new Error(ERROR_MISSING_METHOD);\n    }\n\n    const formattedRequest = {\n      id: typeof request.id === \"undefined\" ? payloadId() : request.id,\n      jsonrpc: \"2.0\",\n      method: request.method,\n      params: typeof request.params === \"undefined\" ? [] : request.params\n    };\n    return formattedRequest;\n  }\n\n  _formatResponse(response) {\n    if (typeof response.id === \"undefined\") {\n      throw new Error(ERROR_MISSING_ID);\n    }\n\n    const baseResponse = {\n      id: response.id,\n      jsonrpc: \"2.0\"\n    };\n\n    if (isJsonRpcResponseError(response)) {\n      const error = formatRpcError(response.error);\n      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), {\n        error\n      });\n      return errorResponse;\n    } else if (isJsonRpcResponseSuccess(response)) {\n      const successResponse = Object.assign(Object.assign({}, baseResponse), response);\n      return successResponse;\n    }\n\n    throw new Error(ERROR_INVALID_RESPONSE);\n  }\n\n  _handleSessionDisconnect(errorMsg) {\n    const message = errorMsg || \"Session Disconnected\";\n\n    if (!this._connected) {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.close();\n      }\n\n      removeLocal(mobileLinkChoiceKey);\n    }\n\n    if (this._connected) {\n      this._connected = false;\n    }\n\n    if (this._handshakeId) {\n      this._handshakeId = 0;\n    }\n\n    if (this._handshakeTopic) {\n      this._handshakeTopic = \"\";\n    }\n\n    if (this._peerId) {\n      this._peerId = \"\";\n    }\n\n    this._eventManager.trigger({\n      event: \"disconnect\",\n      params: [{\n        message\n      }]\n    });\n\n    this._removeStorageSession();\n\n    this.transportClose();\n  }\n\n  _handleSessionResponse(errorMsg, sessionParams) {\n    if (sessionParams) {\n      if (sessionParams.approved) {\n        if (!this._connected) {\n          this._connected = true;\n\n          if (sessionParams.chainId) {\n            this.chainId = sessionParams.chainId;\n          }\n\n          if (sessionParams.accounts) {\n            this.accounts = sessionParams.accounts;\n          }\n\n          if (sessionParams.peerId && !this.peerId) {\n            this.peerId = sessionParams.peerId;\n          }\n\n          if (sessionParams.peerMeta && !this.peerMeta) {\n            this.peerMeta = sessionParams.peerMeta;\n          }\n\n          this._eventManager.trigger({\n            event: \"connect\",\n            params: [{\n              peerId: this.peerId,\n              peerMeta: this.peerMeta,\n              chainId: this.chainId,\n              accounts: this.accounts\n            }]\n          });\n        } else {\n          if (sessionParams.chainId) {\n            this.chainId = sessionParams.chainId;\n          }\n\n          if (sessionParams.accounts) {\n            this.accounts = sessionParams.accounts;\n          }\n\n          this._eventManager.trigger({\n            event: \"session_update\",\n            params: [{\n              chainId: this.chainId,\n              accounts: this.accounts\n            }]\n          });\n        }\n\n        this._manageStorageSession();\n      } else {\n        this._handleSessionDisconnect(errorMsg);\n      }\n    } else {\n      this._handleSessionDisconnect(errorMsg);\n    }\n  }\n\n  async _handleIncomingMessages(socketMessage) {\n    const activeTopics = [this.clientId, this.handshakeTopic];\n\n    if (!activeTopics.includes(socketMessage.topic)) {\n      return;\n    }\n\n    let encryptionPayload;\n\n    try {\n      encryptionPayload = JSON.parse(socketMessage.payload);\n    } catch (error) {\n      return;\n    }\n\n    const payload = await this._decrypt(encryptionPayload);\n\n    if (payload) {\n      this._eventManager.trigger(payload);\n    }\n  }\n\n  _subscribeToSessionRequest() {\n    this._transport.subscribe(this.handshakeTopic);\n  }\n\n  _subscribeToResponse(id, callback) {\n    this.on(`response:${id}`, callback);\n  }\n\n  _subscribeToSessionResponse(id, errorMsg) {\n    this._subscribeToResponse(id, (error, payload) => {\n      if (error) {\n        this._handleSessionResponse(error.message);\n\n        return;\n      }\n\n      if (payload.result) {\n        this._handleSessionResponse(errorMsg, payload.result);\n      } else if (payload.error && payload.error.message) {\n        this._handleSessionResponse(payload.error.message);\n      } else {\n        this._handleSessionResponse(errorMsg);\n      }\n    });\n  }\n\n  _subscribeToCallResponse(id) {\n    return new Promise((resolve, reject) => {\n      this._subscribeToResponse(id, (error, payload) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        if (payload.result) {\n          resolve(payload.result);\n        } else if (payload.error && payload.error.message) {\n          reject(new Error(payload.error.message));\n        } else {\n          reject(new Error(ERROR_INVALID_RESPONSE));\n        }\n      });\n    });\n  }\n\n  _subscribeToInternalEvents() {\n    this.on(\"display_uri\", () => {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.open(this.uri, () => {\n          this._eventManager.trigger({\n            event: \"modal_closed\",\n            params: []\n          });\n        }, this._qrcodeModalOptions);\n      }\n    });\n    this.on(\"connect\", () => {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.close();\n      }\n    });\n    this.on(\"call_request_sent\", (error, payload) => {\n      const {\n        request\n      } = payload.params[0];\n\n      if (isMobile() && this._signingMethods.includes(request.method)) {\n        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);\n\n        if (mobileLinkUrl) {\n          window.location.href = mobileLinkUrl.href;\n        }\n      }\n    });\n    this.on(\"wc_sessionRequest\", (error, payload) => {\n      if (error) {\n        this._eventManager.trigger({\n          event: \"error\",\n          params: [{\n            code: \"SESSION_REQUEST_ERROR\",\n            message: error.toString()\n          }]\n        });\n      }\n\n      this.handshakeId = payload.id;\n      this.peerId = payload.params[0].peerId;\n      this.peerMeta = payload.params[0].peerMeta;\n      const internalPayload = Object.assign(Object.assign({}, payload), {\n        method: \"session_request\"\n      });\n\n      this._eventManager.trigger(internalPayload);\n    });\n    this.on(\"wc_sessionUpdate\", (error, payload) => {\n      if (error) {\n        this._handleSessionResponse(error.message);\n      }\n\n      this._handleSessionResponse(\"Session disconnected\", payload.params[0]);\n    });\n  }\n\n  _initTransport() {\n    this._transport.on(\"message\", socketMessage => this._handleIncomingMessages(socketMessage));\n\n    this._transport.on(\"open\", () => this._eventManager.trigger({\n      event: \"transport_open\",\n      params: []\n    }));\n\n    this._transport.on(\"close\", () => this._eventManager.trigger({\n      event: \"transport_close\",\n      params: []\n    }));\n\n    this._transport.on(\"error\", () => this._eventManager.trigger({\n      event: \"transport_error\",\n      params: [\"Websocket connection failed\"]\n    }));\n\n    this._transport.open();\n  }\n\n  _formatUri() {\n    const protocol = this.protocol;\n    const handshakeTopic = this.handshakeTopic;\n    const version = this.version;\n    const bridge = encodeURIComponent(this.bridge);\n    const key = this.key;\n    const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;\n    return uri;\n  }\n\n  _parseUri(uri) {\n    const result = parseWalletConnectUri(uri);\n\n    if (result.protocol === this.protocol) {\n      if (!result.handshakeTopic) {\n        throw Error(\"Invalid or missing handshakeTopic parameter value\");\n      }\n\n      const handshakeTopic = result.handshakeTopic;\n\n      if (!result.bridge) {\n        throw Error(\"Invalid or missing bridge url parameter value\");\n      }\n\n      const bridge = decodeURIComponent(result.bridge);\n\n      if (!result.key) {\n        throw Error(\"Invalid or missing key parameter value\");\n      }\n\n      const key = result.key;\n      return {\n        handshakeTopic,\n        bridge,\n        key\n      };\n    } else {\n      throw new Error(ERROR_INVALID_URI);\n    }\n  }\n\n  async _generateKey() {\n    if (this._cryptoLib) {\n      const result = await this._cryptoLib.generateKey();\n      return result;\n    }\n\n    return null;\n  }\n\n  async _encrypt(data) {\n    const key = this._key;\n\n    if (this._cryptoLib && key) {\n      const result = await this._cryptoLib.encrypt(data, key);\n      return result;\n    }\n\n    return null;\n  }\n\n  async _decrypt(payload) {\n    const key = this._key;\n\n    if (this._cryptoLib && key) {\n      const result = await this._cryptoLib.decrypt(payload, key);\n      return result;\n    }\n\n    return null;\n  }\n\n  _getStorageSession() {\n    let result = null;\n\n    if (this._sessionStorage) {\n      result = this._sessionStorage.getSession();\n    }\n\n    return result;\n  }\n\n  _setStorageSession() {\n    if (this._sessionStorage) {\n      this._sessionStorage.setSession(this.session);\n    }\n  }\n\n  _removeStorageSession() {\n    if (this._sessionStorage) {\n      this._sessionStorage.removeSession();\n    }\n  }\n\n  _manageStorageSession() {\n    if (this._connected) {\n      this._setStorageSession();\n    } else {\n      this._removeStorageSession();\n    }\n  }\n\n  _registerPushServer(pushServerOpts) {\n    if (!pushServerOpts.url || typeof pushServerOpts.url !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.url parameter value\");\n    }\n\n    if (!pushServerOpts.type || typeof pushServerOpts.type !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.type parameter value\");\n    }\n\n    if (!pushServerOpts.token || typeof pushServerOpts.token !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.token parameter value\");\n    }\n\n    const pushSubscription = {\n      bridge: this.bridge,\n      topic: this.clientId,\n      type: pushServerOpts.type,\n      token: pushServerOpts.token,\n      peerName: \"\",\n      language: pushServerOpts.language || \"\"\n    };\n    this.on(\"connect\", async (error, payload) => {\n      if (error) {\n        throw error;\n      }\n\n      if (pushServerOpts.peerMeta) {\n        const peerName = payload.params[0].peerMeta.name;\n        pushSubscription.peerName = peerName;\n      }\n\n      try {\n        const response = await fetch(`${pushServerOpts.url}/new`, {\n          method: \"POST\",\n          headers: {\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify(pushSubscription)\n        });\n        const json = await response.json();\n\n        if (!json.success) {\n          throw Error(\"Failed to register in Push Server\");\n        }\n      } catch (error) {\n        throw Error(\"Failed to register in Push Server\");\n      }\n    });\n  }\n\n}\n\nexport default Connector;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { parsePersonalSign, parseTransactionData, convertArrayBufferToHex, convertHexToArrayBuffer, getClientMeta, payloadId, uuid, formatRpcError, parseWalletConnectUri, convertNumberToHex, isJsonRpcResponseSuccess, isJsonRpcResponseError, isSilentPayload, getLocal, signingMethods, mobileLinkChoiceKey, isMobile, removeLocal, } from \"@walletconnect/utils\";\nimport SocketTransport from \"@walletconnect/socket-transport\";\nimport { ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_MISSING_REQUIRED, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED, } from \"./errors\";\nimport EventManager from \"./events\";\nimport SessionStorage from \"./storage\";\nimport { getBridgeUrl } from \"./url\";\nclass Connector {\n    constructor(opts) {\n        this.protocol = \"wc\";\n        this.version = 1;\n        this._bridge = \"\";\n        this._key = null;\n        this._clientId = \"\";\n        this._clientMeta = null;\n        this._peerId = \"\";\n        this._peerMeta = null;\n        this._handshakeId = 0;\n        this._handshakeTopic = \"\";\n        this._connected = false;\n        this._accounts = [];\n        this._chainId = 0;\n        this._networkId = 0;\n        this._rpcUrl = \"\";\n        this._eventManager = new EventManager();\n        this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;\n        this._cryptoLib = opts.cryptoLib;\n        this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);\n        this._qrcodeModal = opts.connectorOpts.qrcodeModal;\n        this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;\n        this._signingMethods = [...signingMethods, ...(opts.connectorOpts.signingMethods || [])];\n        if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {\n            throw new Error(ERROR_MISSING_REQUIRED);\n        }\n        if (opts.connectorOpts.bridge) {\n            this.bridge = getBridgeUrl(opts.connectorOpts.bridge);\n        }\n        if (opts.connectorOpts.uri) {\n            this.uri = opts.connectorOpts.uri;\n        }\n        const session = opts.connectorOpts.session || this._getStorageSession();\n        if (session) {\n            this.session = session;\n        }\n        if (this.handshakeId) {\n            this._subscribeToSessionResponse(this.handshakeId, \"Session request rejected\");\n        }\n        this._transport =\n            opts.transport ||\n                new SocketTransport({\n                    protocol: this.protocol,\n                    version: this.version,\n                    url: this.bridge,\n                    subscriptions: [this.clientId],\n                });\n        this._subscribeToInternalEvents();\n        this._initTransport();\n        if (opts.connectorOpts.uri) {\n            this._subscribeToSessionRequest();\n        }\n        if (opts.pushServerOpts) {\n            this._registerPushServer(opts.pushServerOpts);\n        }\n    }\n    set bridge(value) {\n        if (!value) {\n            return;\n        }\n        this._bridge = value;\n    }\n    get bridge() {\n        return this._bridge;\n    }\n    set key(value) {\n        if (!value) {\n            return;\n        }\n        const key = convertHexToArrayBuffer(value);\n        this._key = key;\n    }\n    get key() {\n        if (this._key) {\n            const key = convertArrayBufferToHex(this._key, true);\n            return key;\n        }\n        return \"\";\n    }\n    set clientId(value) {\n        if (!value) {\n            return;\n        }\n        this._clientId = value;\n    }\n    get clientId() {\n        let clientId = this._clientId;\n        if (!clientId) {\n            clientId = this._clientId = uuid();\n        }\n        return this._clientId;\n    }\n    set peerId(value) {\n        if (!value) {\n            return;\n        }\n        this._peerId = value;\n    }\n    get peerId() {\n        return this._peerId;\n    }\n    set clientMeta(value) {\n    }\n    get clientMeta() {\n        let clientMeta = this._clientMeta;\n        if (!clientMeta) {\n            clientMeta = this._clientMeta = getClientMeta();\n        }\n        return clientMeta;\n    }\n    set peerMeta(value) {\n        this._peerMeta = value;\n    }\n    get peerMeta() {\n        const peerMeta = this._peerMeta;\n        return peerMeta;\n    }\n    set handshakeTopic(value) {\n        if (!value) {\n            return;\n        }\n        this._handshakeTopic = value;\n    }\n    get handshakeTopic() {\n        return this._handshakeTopic;\n    }\n    set handshakeId(value) {\n        if (!value) {\n            return;\n        }\n        this._handshakeId = value;\n    }\n    get handshakeId() {\n        return this._handshakeId;\n    }\n    get uri() {\n        const _uri = this._formatUri();\n        return _uri;\n    }\n    set uri(value) {\n        if (!value) {\n            return;\n        }\n        const { handshakeTopic, bridge, key } = this._parseUri(value);\n        this.handshakeTopic = handshakeTopic;\n        this.bridge = bridge;\n        this.key = key;\n    }\n    set chainId(value) {\n        this._chainId = value;\n    }\n    get chainId() {\n        const chainId = this._chainId;\n        return chainId;\n    }\n    set networkId(value) {\n        this._networkId = value;\n    }\n    get networkId() {\n        const networkId = this._networkId;\n        return networkId;\n    }\n    set accounts(value) {\n        this._accounts = value;\n    }\n    get accounts() {\n        const accounts = this._accounts;\n        return accounts;\n    }\n    set rpcUrl(value) {\n        this._rpcUrl = value;\n    }\n    get rpcUrl() {\n        const rpcUrl = this._rpcUrl;\n        return rpcUrl;\n    }\n    set connected(value) {\n    }\n    get connected() {\n        return this._connected;\n    }\n    set pending(value) {\n    }\n    get pending() {\n        return !!this._handshakeTopic;\n    }\n    get session() {\n        return {\n            connected: this.connected,\n            accounts: this.accounts,\n            chainId: this.chainId,\n            bridge: this.bridge,\n            key: this.key,\n            clientId: this.clientId,\n            clientMeta: this.clientMeta,\n            peerId: this.peerId,\n            peerMeta: this.peerMeta,\n            handshakeId: this.handshakeId,\n            handshakeTopic: this.handshakeTopic,\n        };\n    }\n    set session(value) {\n        if (!value) {\n            return;\n        }\n        this._connected = value.connected;\n        this.accounts = value.accounts;\n        this.chainId = value.chainId;\n        this.bridge = value.bridge;\n        this.key = value.key;\n        this.clientId = value.clientId;\n        this.clientMeta = value.clientMeta;\n        this.peerId = value.peerId;\n        this.peerMeta = value.peerMeta;\n        this.handshakeId = value.handshakeId;\n        this.handshakeTopic = value.handshakeTopic;\n    }\n    on(event, callback) {\n        const eventEmitter = {\n            event,\n            callback,\n        };\n        this._eventManager.subscribe(eventEmitter);\n    }\n    off(event) {\n        this._eventManager.unsubscribe(event);\n    }\n    async createInstantRequest(instantRequest) {\n        this._key = await this._generateKey();\n        const request = this._formatRequest({\n            method: \"wc_instantRequest\",\n            params: [\n                {\n                    peerId: this.clientId,\n                    peerMeta: this.clientMeta,\n                    request: this._formatRequest(instantRequest),\n                },\n            ],\n        });\n        this.handshakeId = request.id;\n        this.handshakeTopic = uuid();\n        this._eventManager.trigger({\n            event: \"display_uri\",\n            params: [this.uri],\n        });\n        this.on(\"modal_closed\", () => {\n            throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);\n        });\n        const endInstantRequest = () => {\n            this.killSession();\n        };\n        try {\n            const result = await this._sendCallRequest(request);\n            if (result) {\n                endInstantRequest();\n            }\n            return result;\n        }\n        catch (error) {\n            endInstantRequest();\n            throw error;\n        }\n    }\n    async connect(opts) {\n        if (!this._qrcodeModal) {\n            throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);\n        }\n        if (this.connected) {\n            return {\n                chainId: this.chainId,\n                accounts: this.accounts,\n            };\n        }\n        await this.createSession(opts);\n        return new Promise(async (resolve, reject) => {\n            this.on(\"modal_closed\", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));\n            this.on(\"connect\", (error, payload) => {\n                if (error) {\n                    return reject(error);\n                }\n                resolve(payload.params[0]);\n            });\n        });\n    }\n    async createSession(opts) {\n        if (this._connected) {\n            throw new Error(ERROR_SESSION_CONNECTED);\n        }\n        if (this.pending) {\n            return;\n        }\n        this._key = await this._generateKey();\n        const request = this._formatRequest({\n            method: \"wc_sessionRequest\",\n            params: [\n                {\n                    peerId: this.clientId,\n                    peerMeta: this.clientMeta,\n                    chainId: opts && opts.chainId ? opts.chainId : null,\n                },\n            ],\n        });\n        this.handshakeId = request.id;\n        this.handshakeTopic = uuid();\n        this._sendSessionRequest(request, \"Session update rejected\", {\n            topic: this.handshakeTopic,\n        });\n        this._eventManager.trigger({\n            event: \"display_uri\",\n            params: [this.uri],\n        });\n    }\n    approveSession(sessionStatus) {\n        if (this._connected) {\n            throw new Error(ERROR_SESSION_CONNECTED);\n        }\n        this.chainId = sessionStatus.chainId;\n        this.accounts = sessionStatus.accounts;\n        this.networkId = sessionStatus.networkId || 0;\n        this.rpcUrl = sessionStatus.rpcUrl || \"\";\n        const sessionParams = {\n            approved: true,\n            chainId: this.chainId,\n            networkId: this.networkId,\n            accounts: this.accounts,\n            rpcUrl: this.rpcUrl,\n            peerId: this.clientId,\n            peerMeta: this.clientMeta,\n        };\n        const response = {\n            id: this.handshakeId,\n            jsonrpc: \"2.0\",\n            result: sessionParams,\n        };\n        this._sendResponse(response);\n        this._connected = true;\n        this._setStorageSession();\n        this._eventManager.trigger({\n            event: \"connect\",\n            params: [\n                {\n                    peerId: this.peerId,\n                    peerMeta: this.peerMeta,\n                    chainId: this.chainId,\n                    accounts: this.accounts,\n                },\n            ],\n        });\n    }\n    rejectSession(sessionError) {\n        if (this._connected) {\n            throw new Error(ERROR_SESSION_CONNECTED);\n        }\n        const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;\n        const response = this._formatResponse({\n            id: this.handshakeId,\n            error: { message },\n        });\n        this._sendResponse(response);\n        this._connected = false;\n        this._eventManager.trigger({\n            event: \"disconnect\",\n            params: [{ message }],\n        });\n        this._removeStorageSession();\n    }\n    updateSession(sessionStatus) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        this.chainId = sessionStatus.chainId;\n        this.accounts = sessionStatus.accounts;\n        this.networkId = sessionStatus.networkId || 0;\n        this.rpcUrl = sessionStatus.rpcUrl || \"\";\n        const sessionParams = {\n            approved: true,\n            chainId: this.chainId,\n            networkId: this.networkId,\n            accounts: this.accounts,\n            rpcUrl: this.rpcUrl,\n        };\n        const request = this._formatRequest({\n            method: \"wc_sessionUpdate\",\n            params: [sessionParams],\n        });\n        this._sendSessionRequest(request, \"Session update rejected\");\n        this._eventManager.trigger({\n            event: \"session_update\",\n            params: [\n                {\n                    chainId: this.chainId,\n                    accounts: this.accounts,\n                },\n            ],\n        });\n        this._manageStorageSession();\n    }\n    async killSession(sessionError) {\n        const message = sessionError ? sessionError.message : \"Session Disconnected\";\n        const sessionParams = {\n            approved: false,\n            chainId: null,\n            networkId: null,\n            accounts: null,\n        };\n        const request = this._formatRequest({\n            method: \"wc_sessionUpdate\",\n            params: [sessionParams],\n        });\n        await this._sendRequest(request);\n        this._handleSessionDisconnect(message);\n    }\n    async sendTransaction(tx) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const parsedTx = parseTransactionData(tx);\n        const request = this._formatRequest({\n            method: \"eth_sendTransaction\",\n            params: [parsedTx],\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signTransaction(tx) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const parsedTx = parseTransactionData(tx);\n        const request = this._formatRequest({\n            method: \"eth_signTransaction\",\n            params: [parsedTx],\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signMessage(params) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const request = this._formatRequest({\n            method: \"eth_sign\",\n            params,\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signPersonalMessage(params) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        params = parsePersonalSign(params);\n        const request = this._formatRequest({\n            method: \"personal_sign\",\n            params,\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signTypedData(params) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const request = this._formatRequest({\n            method: \"eth_signTypedData\",\n            params,\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async updateChain(chainParams) {\n        if (!this._connected) {\n            throw new Error(\"Session currently disconnected\");\n        }\n        const request = this._formatRequest({\n            method: \"wallet_updateChain\",\n            params: [chainParams],\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    unsafeSend(request, options) {\n        this._sendRequest(request, options);\n        this._eventManager.trigger({\n            event: \"call_request_sent\",\n            params: [{ request, options }],\n        });\n        return new Promise((resolve, reject) => {\n            this._subscribeToResponse(request.id, (error, payload) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                if (!payload) {\n                    throw new Error(ERROR_MISSING_JSON_RPC);\n                }\n                resolve(payload);\n            });\n        });\n    }\n    async sendCustomRequest(request, options) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        switch (request.method) {\n            case \"eth_accounts\":\n                return this.accounts;\n            case \"eth_chainId\":\n                return convertNumberToHex(this.chainId);\n            case \"eth_sendTransaction\":\n            case \"eth_signTransaction\":\n                if (request.params) {\n                    request.params[0] = parseTransactionData(request.params[0]);\n                }\n                break;\n            case \"personal_sign\":\n                if (request.params) {\n                    request.params = parsePersonalSign(request.params);\n                }\n                break;\n            default:\n                break;\n        }\n        const formattedRequest = this._formatRequest(request);\n        const result = await this._sendCallRequest(formattedRequest, options);\n        return result;\n    }\n    approveRequest(response) {\n        if (isJsonRpcResponseSuccess(response)) {\n            const formattedResponse = this._formatResponse(response);\n            this._sendResponse(formattedResponse);\n        }\n        else {\n            throw new Error(ERROR_MISSING_RESULT);\n        }\n    }\n    rejectRequest(response) {\n        if (isJsonRpcResponseError(response)) {\n            const formattedResponse = this._formatResponse(response);\n            this._sendResponse(formattedResponse);\n        }\n        else {\n            throw new Error(ERROR_MISSING_ERROR);\n        }\n    }\n    transportClose() {\n        this._transport.close();\n    }\n    async _sendRequest(request, options) {\n        const callRequest = this._formatRequest(request);\n        const encryptionPayload = await this._encrypt(callRequest);\n        const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== \"undefined\" ? options.topic : this.peerId;\n        const payload = JSON.stringify(encryptionPayload);\n        const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== \"undefined\"\n            ? !options.forcePushNotification\n            : isSilentPayload(callRequest);\n        this._transport.send(payload, topic, silent);\n    }\n    async _sendResponse(response) {\n        const encryptionPayload = await this._encrypt(response);\n        const topic = this.peerId;\n        const payload = JSON.stringify(encryptionPayload);\n        const silent = true;\n        this._transport.send(payload, topic, silent);\n    }\n    async _sendSessionRequest(request, errorMsg, options) {\n        this._sendRequest(request, options);\n        this._subscribeToSessionResponse(request.id, errorMsg);\n    }\n    _sendCallRequest(request, options) {\n        this._sendRequest(request, options);\n        this._eventManager.trigger({\n            event: \"call_request_sent\",\n            params: [{ request, options }],\n        });\n        return this._subscribeToCallResponse(request.id);\n    }\n    _formatRequest(request) {\n        if (typeof request.method === \"undefined\") {\n            throw new Error(ERROR_MISSING_METHOD);\n        }\n        const formattedRequest = {\n            id: typeof request.id === \"undefined\" ? payloadId() : request.id,\n            jsonrpc: \"2.0\",\n            method: request.method,\n            params: typeof request.params === \"undefined\" ? [] : request.params,\n        };\n        return formattedRequest;\n    }\n    _formatResponse(response) {\n        if (typeof response.id === \"undefined\") {\n            throw new Error(ERROR_MISSING_ID);\n        }\n        const baseResponse = { id: response.id, jsonrpc: \"2.0\" };\n        if (isJsonRpcResponseError(response)) {\n            const error = formatRpcError(response.error);\n            const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });\n            return errorResponse;\n        }\n        else if (isJsonRpcResponseSuccess(response)) {\n            const successResponse = Object.assign(Object.assign({}, baseResponse), response);\n            return successResponse;\n        }\n        throw new Error(ERROR_INVALID_RESPONSE);\n    }\n    _handleSessionDisconnect(errorMsg) {\n        const message = errorMsg || \"Session Disconnected\";\n        if (!this._connected) {\n            if (this._qrcodeModal) {\n                this._qrcodeModal.close();\n            }\n            removeLocal(mobileLinkChoiceKey);\n        }\n        if (this._connected) {\n            this._connected = false;\n        }\n        if (this._handshakeId) {\n            this._handshakeId = 0;\n        }\n        if (this._handshakeTopic) {\n            this._handshakeTopic = \"\";\n        }\n        if (this._peerId) {\n            this._peerId = \"\";\n        }\n        this._eventManager.trigger({\n            event: \"disconnect\",\n            params: [{ message }],\n        });\n        this._removeStorageSession();\n        this.transportClose();\n    }\n    _handleSessionResponse(errorMsg, sessionParams) {\n        if (sessionParams) {\n            if (sessionParams.approved) {\n                if (!this._connected) {\n                    this._connected = true;\n                    if (sessionParams.chainId) {\n                        this.chainId = sessionParams.chainId;\n                    }\n                    if (sessionParams.accounts) {\n                        this.accounts = sessionParams.accounts;\n                    }\n                    if (sessionParams.peerId && !this.peerId) {\n                        this.peerId = sessionParams.peerId;\n                    }\n                    if (sessionParams.peerMeta && !this.peerMeta) {\n                        this.peerMeta = sessionParams.peerMeta;\n                    }\n                    this._eventManager.trigger({\n                        event: \"connect\",\n                        params: [\n                            {\n                                peerId: this.peerId,\n                                peerMeta: this.peerMeta,\n                                chainId: this.chainId,\n                                accounts: this.accounts,\n                            },\n                        ],\n                    });\n                }\n                else {\n                    if (sessionParams.chainId) {\n                        this.chainId = sessionParams.chainId;\n                    }\n                    if (sessionParams.accounts) {\n                        this.accounts = sessionParams.accounts;\n                    }\n                    this._eventManager.trigger({\n                        event: \"session_update\",\n                        params: [\n                            {\n                                chainId: this.chainId,\n                                accounts: this.accounts,\n                            },\n                        ],\n                    });\n                }\n                this._manageStorageSession();\n            }\n            else {\n                this._handleSessionDisconnect(errorMsg);\n            }\n        }\n        else {\n            this._handleSessionDisconnect(errorMsg);\n        }\n    }\n    async _handleIncomingMessages(socketMessage) {\n        const activeTopics = [this.clientId, this.handshakeTopic];\n        if (!activeTopics.includes(socketMessage.topic)) {\n            return;\n        }\n        let encryptionPayload;\n        try {\n            encryptionPayload = JSON.parse(socketMessage.payload);\n        }\n        catch (error) {\n            return;\n        }\n        const payload = await this._decrypt(encryptionPayload);\n        if (payload) {\n            this._eventManager.trigger(payload);\n        }\n    }\n    _subscribeToSessionRequest() {\n        this._transport.subscribe(this.handshakeTopic);\n    }\n    _subscribeToResponse(id, callback) {\n        this.on(`response:${id}`, callback);\n    }\n    _subscribeToSessionResponse(id, errorMsg) {\n        this._subscribeToResponse(id, (error, payload) => {\n            if (error) {\n                this._handleSessionResponse(error.message);\n                return;\n            }\n            if (payload.result) {\n                this._handleSessionResponse(errorMsg, payload.result);\n            }\n            else if (payload.error && payload.error.message) {\n                this._handleSessionResponse(payload.error.message);\n            }\n            else {\n                this._handleSessionResponse(errorMsg);\n            }\n        });\n    }\n    _subscribeToCallResponse(id) {\n        return new Promise((resolve, reject) => {\n            this._subscribeToResponse(id, (error, payload) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                if (payload.result) {\n                    resolve(payload.result);\n                }\n                else if (payload.error && payload.error.message) {\n                    reject(new Error(payload.error.message));\n                }\n                else {\n                    reject(new Error(ERROR_INVALID_RESPONSE));\n                }\n            });\n        });\n    }\n    _subscribeToInternalEvents() {\n        this.on(\"display_uri\", () => {\n            if (this._qrcodeModal) {\n                this._qrcodeModal.open(this.uri, () => {\n                    this._eventManager.trigger({\n                        event: \"modal_closed\",\n                        params: [],\n                    });\n                }, this._qrcodeModalOptions);\n            }\n        });\n        this.on(\"connect\", () => {\n            if (this._qrcodeModal) {\n                this._qrcodeModal.close();\n            }\n        });\n        this.on(\"call_request_sent\", (error, payload) => {\n            const { request } = payload.params[0];\n            if (isMobile() && this._signingMethods.includes(request.method)) {\n                const mobileLinkUrl = getLocal(mobileLinkChoiceKey);\n                if (mobileLinkUrl) {\n                    window.location.href = mobileLinkUrl.href;\n                }\n            }\n        });\n        this.on(\"wc_sessionRequest\", (error, payload) => {\n            if (error) {\n                this._eventManager.trigger({\n                    event: \"error\",\n                    params: [\n                        {\n                            code: \"SESSION_REQUEST_ERROR\",\n                            message: error.toString(),\n                        },\n                    ],\n                });\n            }\n            this.handshakeId = payload.id;\n            this.peerId = payload.params[0].peerId;\n            this.peerMeta = payload.params[0].peerMeta;\n            const internalPayload = Object.assign(Object.assign({}, payload), { method: \"session_request\" });\n            this._eventManager.trigger(internalPayload);\n        });\n        this.on(\"wc_sessionUpdate\", (error, payload) => {\n            if (error) {\n                this._handleSessionResponse(error.message);\n            }\n            this._handleSessionResponse(\"Session disconnected\", payload.params[0]);\n        });\n    }\n    _initTransport() {\n        this._transport.on(\"message\", (socketMessage) => this._handleIncomingMessages(socketMessage));\n        this._transport.on(\"open\", () => this._eventManager.trigger({ event: \"transport_open\", params: [] }));\n        this._transport.on(\"close\", () => this._eventManager.trigger({ event: \"transport_close\", params: [] }));\n        this._transport.on(\"error\", () => this._eventManager.trigger({\n            event: \"transport_error\",\n            params: [\"Websocket connection failed\"],\n        }));\n        this._transport.open();\n    }\n    _formatUri() {\n        const protocol = this.protocol;\n        const handshakeTopic = this.handshakeTopic;\n        const version = this.version;\n        const bridge = encodeURIComponent(this.bridge);\n        const key = this.key;\n        const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;\n        return uri;\n    }\n    _parseUri(uri) {\n        const result = parseWalletConnectUri(uri);\n        if (result.protocol === this.protocol) {\n            if (!result.handshakeTopic) {\n                throw Error(\"Invalid or missing handshakeTopic parameter value\");\n            }\n            const handshakeTopic = result.handshakeTopic;\n            if (!result.bridge) {\n                throw Error(\"Invalid or missing bridge url parameter value\");\n            }\n            const bridge = decodeURIComponent(result.bridge);\n            if (!result.key) {\n                throw Error(\"Invalid or missing key parameter value\");\n            }\n            const key = result.key;\n            return { handshakeTopic, bridge, key };\n        }\n        else {\n            throw new Error(ERROR_INVALID_URI);\n        }\n    }\n    async _generateKey() {\n        if (this._cryptoLib) {\n            const result = await this._cryptoLib.generateKey();\n            return result;\n        }\n        return null;\n    }\n    async _encrypt(data) {\n        const key = this._key;\n        if (this._cryptoLib && key) {\n            const result = await this._cryptoLib.encrypt(data, key);\n            return result;\n        }\n        return null;\n    }\n    async _decrypt(payload) {\n        const key = this._key;\n        if (this._cryptoLib && key) {\n            const result = await this._cryptoLib.decrypt(payload, key);\n            return result;\n        }\n        return null;\n    }\n    _getStorageSession() {\n        let result = null;\n        if (this._sessionStorage) {\n            result = this._sessionStorage.getSession();\n        }\n        return result;\n    }\n    _setStorageSession() {\n        if (this._sessionStorage) {\n            this._sessionStorage.setSession(this.session);\n        }\n    }\n    _removeStorageSession() {\n        if (this._sessionStorage) {\n            this._sessionStorage.removeSession();\n        }\n    }\n    _manageStorageSession() {\n        if (this._connected) {\n            this._setStorageSession();\n        }\n        else {\n            this._removeStorageSession();\n        }\n    }\n    _registerPushServer(pushServerOpts) {\n        if (!pushServerOpts.url || typeof pushServerOpts.url !== \"string\") {\n            throw Error(\"Invalid or missing pushServerOpts.url parameter value\");\n        }\n        if (!pushServerOpts.type || typeof pushServerOpts.type !== \"string\") {\n            throw Error(\"Invalid or missing pushServerOpts.type parameter value\");\n        }\n        if (!pushServerOpts.token || typeof pushServerOpts.token !== \"string\") {\n            throw Error(\"Invalid or missing pushServerOpts.token parameter value\");\n        }\n        const pushSubscription = {\n            bridge: this.bridge,\n            topic: this.clientId,\n            type: pushServerOpts.type,\n            token: pushServerOpts.token,\n            peerName: \"\",\n            language: pushServerOpts.language || \"\",\n        };\n        this.on(\"connect\", async (error, payload) => {\n            if (error) {\n                throw error;\n            }\n            if (pushServerOpts.peerMeta) {\n                const peerName = payload.params[0].peerMeta.name;\n                pushSubscription.peerName = peerName;\n            }\n            try {\n                const response = await fetch(`${pushServerOpts.url}/new`, {\n                    method: \"POST\",\n                    headers: {\n                        Accept: \"application/json\",\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify(pushSubscription),\n                });\n                const json = await response.json();\n                if (!json.success) {\n                    throw Error(\"Failed to register in Push Server\");\n                }\n            }\n            catch (error) {\n                throw Error(\"Failed to register in Push Server\");\n            }\n        });\n    }\n}\nexport default Connector;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}