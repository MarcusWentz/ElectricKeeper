{"ast":null,"code":"/*\r\n\tISC License\r\n\r\n\tCopyright (c) 2019, Pierre-Louis Despaigne\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted, provided that the above\r\n\tcopyright notice and this permission notice appear in all copies.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r\n\tWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r\n\tMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r\n\tANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r\n\tWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r\n\tACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r\n\tOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r\n*/\nvar multiC = require('multicodec');\n\nvar _require = require('./profiles'),\n    hexStringToBuffer = _require.hexStringToBuffer,\n    profiles = _require.profiles;\n\nvar _require2 = require('./helpers'),\n    cidV0ToV1Base32 = _require2.cidV0ToV1Base32;\n\nmodule.exports = {\n  //export some helpers functions\n  helpers: {\n    cidV0ToV1Base32: cidV0ToV1Base32\n  },\n\n  /**\r\n  * Decode a Content Hash.\r\n  * @param {string} hash an hex string containing a content hash\r\n  * @return {string} the decoded content\r\n  */\n  decode: function decode(contentHash) {\n    var buffer = hexStringToBuffer(contentHash);\n    var codec = multiC.getCodec(buffer);\n    var value = multiC.rmPrefix(buffer);\n    var profile = profiles[codec];\n    if (!profile) profile = profiles['default'];\n    return profile.decode(value);\n  },\n\n  /**\r\n  * Encode an IPFS address into a content hash\r\n  * @param {string} ipfsHash string containing an IPFS address\r\n  * @return {string} the resulting content hash\r\n  */\n  fromIpfs: function fromIpfs(ipfsHash) {\n    return this.encode('ipfs-ns', ipfsHash);\n  },\n\n  /**\r\n  * Encode a Swarm address into a content hash\r\n  * @param {string} swarmHash string containing a Swarm address\r\n  * @return {string} the resulting content hash\r\n  */\n  fromSwarm: function fromSwarm(swarmHash) {\n    return this.encode('swarm-ns', swarmHash);\n  },\n\n  /**\r\n  * General purpose encoding function\r\n   * @param {string} codec \r\n   * @param {string} value \r\n   */\n  encode: function encode(codec, value) {\n    var profile = profiles[codec];\n    if (!profile) profile = profiles['default'];\n    var encodedValue = profile.encode(value);\n    return multiC.addPrefix(codec, encodedValue).toString('hex');\n  },\n\n  /**\r\n  * Extract the codec of a content hash\r\n  * @param {string} hash hex string containing a content hash\r\n  * @return {string} the extracted codec\r\n  */\n  getCodec: function getCodec(hash) {\n    var buffer = hexStringToBuffer(hash);\n    return multiC.getCodec(buffer);\n  }\n};","map":{"version":3,"sources":["/home/johanna/Desktop/ElectricalEthereum/frontend/node_modules/content-hash/src/index.js"],"names":["multiC","require","hexStringToBuffer","profiles","cidV0ToV1Base32","module","exports","helpers","decode","contentHash","buffer","codec","getCodec","value","rmPrefix","profile","fromIpfs","ipfsHash","encode","fromSwarm","swarmHash","encodedValue","addPrefix","toString","hash"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,YAAD,CAAtB;;AAEA,eAAwCA,OAAO,CAAC,YAAD,CAA/C;AAAA,IAAQC,iBAAR,YAAQA,iBAAR;AAAA,IAA2BC,QAA3B,YAA2BA,QAA3B;;AACA,gBAA4BF,OAAO,CAAC,WAAD,CAAnC;AAAA,IAAQG,eAAR,aAAQA,eAAR;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AAEhB;AACAC,EAAAA,OAAO,EAAE;AACRH,IAAAA,eAAe,EAAfA;AADQ,GAHO;;AAOhB;AACD;AACA;AACA;AACA;AACCI,EAAAA,MAAM,EAAE,gBAAUC,WAAV,EAAuB;AAC9B,QAAMC,MAAM,GAAGR,iBAAiB,CAACO,WAAD,CAAhC;AACA,QAAME,KAAK,GAAGX,MAAM,CAACY,QAAP,CAAgBF,MAAhB,CAAd;AACA,QAAMG,KAAK,GAAGb,MAAM,CAACc,QAAP,CAAgBJ,MAAhB,CAAd;AACA,QAAIK,OAAO,GAAGZ,QAAQ,CAACQ,KAAD,CAAtB;AACA,QAAI,CAACI,OAAL,EAAcA,OAAO,GAAGZ,QAAQ,CAAC,SAAD,CAAlB;AACd,WAAOY,OAAO,CAACP,MAAR,CAAeK,KAAf,CAAP;AACA,GAnBe;;AAqBhB;AACD;AACA;AACA;AACA;AACCG,EAAAA,QAAQ,EAAE,kBAAUC,QAAV,EAAoB;AAC7B,WAAO,KAAKC,MAAL,CAAY,SAAZ,EAAuBD,QAAvB,CAAP;AACA,GA5Be;;AA8BhB;AACD;AACA;AACA;AACA;AACCE,EAAAA,SAAS,EAAE,mBAAUC,SAAV,EAAqB;AAC/B,WAAO,KAAKF,MAAL,CAAY,UAAZ,EAAwBE,SAAxB,CAAP;AACA,GArCe;;AAuChB;AACD;AACA;AACA;AACA;AACCF,EAAAA,MAAM,EAAE,gBAAUP,KAAV,EAAiBE,KAAjB,EAAwB;AAC/B,QAAIE,OAAO,GAAGZ,QAAQ,CAACQ,KAAD,CAAtB;AACA,QAAI,CAACI,OAAL,EAAcA,OAAO,GAAGZ,QAAQ,CAAC,SAAD,CAAlB;AACd,QAAMkB,YAAY,GAAGN,OAAO,CAACG,MAAR,CAAeL,KAAf,CAArB;AACA,WAAOb,MAAM,CAACsB,SAAP,CAAiBX,KAAjB,EAAwBU,YAAxB,EAAsCE,QAAtC,CAA+C,KAA/C,CAAP;AACA,GAjDe;;AAmDhB;AACD;AACA;AACA;AACA;AACCX,EAAAA,QAAQ,EAAE,kBAAUY,IAAV,EAAgB;AACzB,QAAId,MAAM,GAAGR,iBAAiB,CAACsB,IAAD,CAA9B;AACA,WAAOxB,MAAM,CAACY,QAAP,CAAgBF,MAAhB,CAAP;AACA;AA3De,CAAjB","sourcesContent":["/*\r\n\tISC License\r\n\r\n\tCopyright (c) 2019, Pierre-Louis Despaigne\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted, provided that the above\r\n\tcopyright notice and this permission notice appear in all copies.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r\n\tWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r\n\tMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r\n\tANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r\n\tWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r\n\tACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r\n\tOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r\n*/\r\n\r\nconst multiC = require('multicodec');\r\n\r\nconst { hexStringToBuffer, profiles } = require('./profiles');\r\nconst { cidV0ToV1Base32 } = require('./helpers');\r\n\r\nmodule.exports = {\r\n\r\n\t//export some helpers functions\r\n\thelpers: {\r\n\t\tcidV0ToV1Base32,\r\n\t},\r\n\r\n\t/**\r\n\t* Decode a Content Hash.\r\n\t* @param {string} hash an hex string containing a content hash\r\n\t* @return {string} the decoded content\r\n\t*/\r\n\tdecode: function (contentHash) {\r\n\t\tconst buffer = hexStringToBuffer(contentHash);\r\n\t\tconst codec = multiC.getCodec(buffer);\r\n\t\tconst value = multiC.rmPrefix(buffer);\r\n\t\tlet profile = profiles[codec];\r\n\t\tif (!profile) profile = profiles['default'];\r\n\t\treturn profile.decode(value);\r\n\t},\r\n\r\n\t/**\r\n\t* Encode an IPFS address into a content hash\r\n\t* @param {string} ipfsHash string containing an IPFS address\r\n\t* @return {string} the resulting content hash\r\n\t*/\r\n\tfromIpfs: function (ipfsHash) {\r\n\t\treturn this.encode('ipfs-ns', ipfsHash);\r\n\t},\r\n\r\n\t/**\r\n\t* Encode a Swarm address into a content hash\r\n\t* @param {string} swarmHash string containing a Swarm address\r\n\t* @return {string} the resulting content hash\r\n\t*/\r\n\tfromSwarm: function (swarmHash) {\r\n\t\treturn this.encode('swarm-ns', swarmHash);\r\n\t},\r\n\r\n\t/**\r\n\t* General purpose encoding function\r\n  * @param {string} codec \r\n  * @param {string} value \r\n  */\r\n\tencode: function (codec, value) {\r\n\t\tlet profile = profiles[codec];\r\n\t\tif (!profile) profile = profiles['default'];\r\n\t\tconst encodedValue = profile.encode(value);\r\n\t\treturn multiC.addPrefix(codec, encodedValue).toString('hex');\r\n\t},\r\n\r\n\t/**\r\n\t* Extract the codec of a content hash\r\n\t* @param {string} hash hex string containing a content hash\r\n\t* @return {string} the extracted codec\r\n\t*/\r\n\tgetCodec: function (hash) {\r\n\t\tlet buffer = hexStringToBuffer(hash);\r\n\t\treturn multiC.getCodec(buffer);\r\n\t},\r\n}\r\n"]},"metadata":{},"sourceType":"script"}