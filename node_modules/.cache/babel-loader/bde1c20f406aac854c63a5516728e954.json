{"ast":null,"code":"var _slicedToArray = require(\"/home/johanna/Desktop/ElectricalEthereum/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar Bytes = require(\"./bytes\");\n\nvar Nat = require(\"./nat\");\n\nvar elliptic = require(\"elliptic\");\n\nvar rlp = require(\"./rlp\");\n\nvar secp256k1 = new elliptic.ec(\"secp256k1\"); // eslint-disable-line\n\nvar _require = require(\"./hash\"),\n    keccak256 = _require.keccak256,\n    keccak256s = _require.keccak256s;\n\nvar create = function create(entropy) {\n  var innerHex = keccak256(Bytes.concat(Bytes.random(32), entropy || Bytes.random(32)));\n  var middleHex = Bytes.concat(Bytes.concat(Bytes.random(32), innerHex), Bytes.random(32));\n  var outerHex = keccak256(middleHex);\n  return fromPrivate(outerHex);\n};\n\nvar toChecksum = function toChecksum(address) {\n  var addressHash = keccak256s(address.slice(2));\n  var checksumAddress = \"0x\";\n\n  for (var i = 0; i < 40; i++) {\n    checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n  }\n\n  return checksumAddress;\n};\n\nvar fromPrivate = function fromPrivate(privateKey) {\n  var buffer = new Buffer(privateKey.slice(2), \"hex\");\n  var ecKey = secp256k1.keyFromPrivate(buffer);\n  var publicKey = \"0x\" + ecKey.getPublic(false, 'hex').slice(2);\n  var publicHash = keccak256(publicKey);\n  var address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return {\n    address: address,\n    privateKey: privateKey\n  };\n};\n\nvar encodeSignature = function encodeSignature(_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      v = _ref2[0],\n      r = _ref2[1],\n      s = _ref2[2];\n\n  return Bytes.flatten([r, s, v]);\n};\n\nvar decodeSignature = function decodeSignature(hex) {\n  return [Bytes.slice(64, Bytes.length(hex), hex), Bytes.slice(0, 32, hex), Bytes.slice(32, 64, hex)];\n};\n\nvar makeSigner = function makeSigner(addToV) {\n  return function (hash, privateKey) {\n    var signature = secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2), \"hex\")).sign(new Buffer(hash.slice(2), \"hex\"), {\n      canonical: true\n    });\n    return encodeSignature([Nat.fromString(Bytes.fromNumber(addToV + signature.recoveryParam)), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.r.toString(16))), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.s.toString(16)))]);\n  };\n};\n\nvar sign = makeSigner(27); // v=27|28 instead of 0|1...\n\nvar recover = function recover(hash, signature) {\n  var vals = decodeSignature(signature);\n  var vrs = {\n    v: Bytes.toNumber(vals[0]),\n    r: vals[1].slice(2),\n    s: vals[2].slice(2)\n  };\n  var ecPublicKey = secp256k1.recoverPubKey(new Buffer(hash.slice(2), \"hex\"), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n\n  var publicKey = \"0x\" + ecPublicKey.encode(\"hex\", false).slice(2);\n  var publicHash = keccak256(publicKey);\n  var address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return address;\n};\n\nmodule.exports = {\n  create: create,\n  toChecksum: toChecksum,\n  fromPrivate: fromPrivate,\n  sign: sign,\n  makeSigner: makeSigner,\n  recover: recover,\n  encodeSignature: encodeSignature,\n  decodeSignature: decodeSignature\n};","map":{"version":3,"sources":["/home/johanna/Desktop/ElectricalEthereum/frontend/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/account.js"],"names":["Bytes","require","Nat","elliptic","rlp","secp256k1","ec","keccak256","keccak256s","create","entropy","innerHex","concat","random","middleHex","outerHex","fromPrivate","toChecksum","address","addressHash","slice","checksumAddress","i","parseInt","toUpperCase","privateKey","buffer","Buffer","ecKey","keyFromPrivate","publicKey","getPublic","publicHash","encodeSignature","v","r","s","flatten","decodeSignature","hex","length","makeSigner","addToV","hash","signature","sign","canonical","fromString","fromNumber","recoveryParam","pad","fromNat","toString","recover","vals","vrs","toNumber","ecPublicKey","recoverPubKey","encode","module","exports"],"mappings":"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","sourcesContent":["const Bytes = require(\"./bytes\");\nconst Nat = require(\"./nat\");\nconst elliptic = require(\"elliptic\");\nconst rlp = require(\"./rlp\");\nconst secp256k1 = new elliptic.ec(\"secp256k1\"); // eslint-disable-line\nconst { keccak256, keccak256s } = require(\"./hash\");\n\nconst create = entropy => {\n  const innerHex = keccak256(Bytes.concat(Bytes.random(32), entropy || Bytes.random(32)));\n  const middleHex = Bytes.concat(Bytes.concat(Bytes.random(32), innerHex), Bytes.random(32));\n  const outerHex = keccak256(middleHex);\n  return fromPrivate(outerHex);\n};\n\nconst toChecksum = address => {\n  const addressHash = keccak256s(address.slice(2));\n  let checksumAddress = \"0x\";\n  for (let i = 0; i < 40; i++) checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n  return checksumAddress;\n};\n\nconst fromPrivate = privateKey => {\n  const buffer = new Buffer(privateKey.slice(2), \"hex\");\n  const ecKey = secp256k1.keyFromPrivate(buffer);\n  const publicKey = \"0x\" + ecKey.getPublic(false, 'hex').slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return {\n    address: address,\n    privateKey: privateKey\n  };\n};\n\nconst encodeSignature = ([v, r, s]) => Bytes.flatten([r, s, v]);\n\nconst decodeSignature = hex => [Bytes.slice(64, Bytes.length(hex), hex), Bytes.slice(0, 32, hex), Bytes.slice(32, 64, hex)];\n\nconst makeSigner = addToV => (hash, privateKey) => {\n  const signature = secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2), \"hex\")).sign(new Buffer(hash.slice(2), \"hex\"), { canonical: true });\n  return encodeSignature([Nat.fromString(Bytes.fromNumber(addToV + signature.recoveryParam)), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.r.toString(16))), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.s.toString(16)))]);\n};\n\nconst sign = makeSigner(27); // v=27|28 instead of 0|1...\n\nconst recover = (hash, signature) => {\n  const vals = decodeSignature(signature);\n  const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\n  const ecPublicKey = secp256k1.recoverPubKey(new Buffer(hash.slice(2), \"hex\"), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n  const publicKey = \"0x\" + ecPublicKey.encode(\"hex\", false).slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return address;\n};\n\nmodule.exports = {\n  create,\n  toChecksum,\n  fromPrivate,\n  sign,\n  makeSigner,\n  recover,\n  encodeSignature,\n  decodeSignature\n};"]},"metadata":{},"sourceType":"script"}